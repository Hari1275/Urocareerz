{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Foundation: Project Setup & Secure Authentication",
        "description": "Initialize the project repository and implement the core secure email-based OTP authentication system for all user roles.",
        "details": "Setup Next.js project with MongoDB, Prisma, Shadcn UI, and Tailwind CSS. Create a custom email OTP login/registration flow using Brevo. Implement session management with timeouts and refresh tokens. Establish basic database schemas for users.",
        "testStrategy": "Verify project setup by running the dev server. Test user registration with a valid email, OTP reception, and successful login. Test session timeout and invalid OTP scenarios.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the database table(s) to store user information, including email, a hashed password, and timestamps.",
            "dependencies": [],
            "details": "Use a migration tool to create a 'users' table. Key columns should be 'id' (PK), 'email' (unique), 'password_hash' (string), 'created_at', and 'updated_at'. Ensure the password column is large enough for a bcrypt hash. Do not store passwords in plain text.",
            "status": "done",
            "testStrategy": "Verify the migration runs successfully and can be rolled back. Write a unit test using the data model to create and retrieve a dummy user record. Manually inspect the schema to confirm all columns, types, and constraints are correct."
          },
          {
            "id": 2,
            "title": "Create API Endpoint for User Registration",
            "description": "Develop a public API endpoint (e.g., POST /api/register) that allows new users to create an account.",
            "dependencies": [
              1
            ],
            "details": "The endpoint should accept an email and password. It must validate the input (e.g., valid email format, password complexity). Hash the password using a strong library like bcrypt before saving the new user to the database. On success, return a 201 Created status with the new user's ID and email.",
            "status": "done",
            "testStrategy": "Write integration tests for the endpoint. Test the success case with valid data. Test failure cases like duplicate email, invalid email format, and weak password. Verify that the password stored in the database is correctly hashed and does not match the input."
          },
          {
            "id": 3,
            "title": "Implement User Login Endpoint with JWT",
            "description": "Create an API endpoint (e.g., POST /api/login) for user authentication that returns a JSON Web Token (JWT) on success.",
            "dependencies": [
              1
            ],
            "details": "The endpoint accepts an email and password. It should find the user by email, then compare the provided password against the stored hash using bcrypt's compare function. If credentials are valid, generate a signed JWT containing the user ID and an expiration claim. Return the JWT in the response body.",
            "status": "done",
            "testStrategy": "Integration tests: Test successful login with correct credentials, ensuring a valid JWT is returned. Test failed login with an incorrect password or a non-existent email. Decode a valid token in a test to assert its payload contains the correct user ID and 'exp' claim."
          },
          {
            "id": 4,
            "title": "Implement Middleware for Protected API Routes",
            "description": "Create server-side middleware to verify the JWT on incoming requests to secure specific endpoints.",
            "dependencies": [
              3
            ],
            "details": "The middleware should extract the JWT from the 'Authorization: Bearer <token>' header. It must verify the token's signature and check for expiration. If the token is valid, attach the decoded user payload (e.g., user ID) to the request object for use by route handlers. If invalid, respond with a 401 Unauthorized error.",
            "status": "done",
            "testStrategy": "Unit test the middleware logic in isolation. Write integration tests for a sample protected endpoint: test with a valid token, an expired token, a malformed token, and no token, asserting the correct HTTP status code is returned for each case."
          },
          {
            "id": 5,
            "title": "Develop Frontend Registration and Login Forms",
            "description": "Build the UI components for the registration and login pages using a frontend framework.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create two separate forms with fields for email and password. Implement client-side validation. On submission, make API calls to the registration or login endpoints. On successful login, store the received JWT securely (e.g., in an HttpOnly cookie or local storage) and redirect the user to a protected area.",
            "status": "done",
            "testStrategy": "Use component tests to verify form validation and state management. Use end-to-end tests (e.g., with Cypress or Playwright) to simulate a user registering and then logging in, mocking the API responses to test UI behavior in success and error states."
          },
          {
            "id": 6,
            "title": "Create Protected User Profile Page",
            "description": "Build a user profile page that is only accessible to authenticated users and displays their information.",
            "dependencies": [
              4,
              5
            ],
            "details": "Create a new frontend route (e.g., /profile) that is wrapped in a private route component. This component should check for a valid JWT; if none exists, it should redirect to the login page. The page should fetch user data from a new, protected backend endpoint (e.g., GET /api/users/me) which uses the authentication middleware.",
            "status": "done",
            "testStrategy": "End-to-end tests: 1) Attempt to access /profile directly without logging in and assert a redirect to the login page. 2) Log in, navigate to /profile, and assert that the user's data is fetched and displayed correctly. Test the logout functionality, ensuring the token is cleared and the user is redirected."
          }
        ]
      },
      {
        "id": 2,
        "title": "User Profile Management (Mentor & Mentee)",
        "description": "Develop the functionality for Mentees and Mentors to create, view, and edit their profiles.",
        "details": "Create profile pages for both roles. Mentee Profile: Education, interests, location, purpose of registration. Mentor Profile: Specialty/sub-specialty, workplace, availability status (static text). Ensure profiles can be updated by the user.",
        "testStrategy": "After logging in as a mentee/mentor, verify that the profile creation form is presented and can be submitted. Test editing and saving changes to the profile fields.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update Database Schema for Profile Management",
            "description": "Extend the existing user schema to include profile fields for both mentors and mentees",
            "details": "Add profile-related fields to the users table or create separate profile tables. For mentees: education, interests, location, purpose_of_registration. For mentors: specialty, sub_specialty, workplace, availability_status. Use Prisma migrations to update the schema.\n<info added on 2025-07-18T10:32:28.526Z>\nThe database schema has been updated. The API endpoints should be built based on the new `Profile` model, which has a one-to-one relationship with the `User` model.\n\n**Finalized Profile Model Fields:**\n*   **Common:** bio, location, avatar\n*   **Mentee-specific:** education, interests (String array), purposeOfRegistration\n*   **Mentor-specific:** specialty, subSpecialty, workplace, availabilityStatus, yearsOfExperience\n</info added on 2025-07-18T10:32:28.526Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 2,
            "title": "Create Profile API Endpoints",
            "description": "Develop API endpoints for creating, reading, updating, and deleting user profiles",
            "details": "Create RESTful API endpoints: GET /api/profile (get current user's profile), PUT /api/profile (update profile), POST /api/profile (create profile if doesn't exist). Handle both mentor and mentee profile types with appropriate validation.\n<info added on 2025-07-18T10:33:47.933Z>\n**Implementation Update:**\nThe profile API endpoints have been created in `/api/profile/route.ts`.\n- **GET `/api/profile`**: Retrieves the current authenticated user's profile.\n- **POST `/api/profile`**: Creates a new profile, with checks to prevent duplicates.\n- **PUT `/api/profile`**: Updates an existing profile, using an upsert for flexibility.\nKey features include JWT authentication, validation for role-specific fields (mentor/mentee), and robust error handling. A Prisma query issue involving conflicting `select` and `include` statements was also resolved. The API is now ready for frontend integration.\n</info added on 2025-07-18T10:33:47.933Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 3,
            "title": "Build Profile Management UI Components",
            "description": "Create React components for profile forms and display",
            "details": "Create reusable form components for profile editing. Include form validation, error handling, and success feedback. Design separate forms for mentor and mentee profiles with appropriate fields. Use modern UI components and responsive design.\n<info added on 2025-07-18T10:36:45.217Z>\nSuccessfully created profile management UI components:\n\n1.  **ProfileForm Component** (`src/components/ProfileForm.tsx`):\n    *   A comprehensive, reusable form handling both mentor and mentee profiles.\n    *   Features role-based conditional rendering for specific fields (e.g., mentee's education/purpose, mentor's specialty/workplace).\n    *   Includes form validation, error handling, and supports comma-separated input for interests.\n\n2.  **ProfileDisplay Component** (`src/components/ProfileDisplay.tsx`):\n    *   A read-only component to display user profile data.\n    *   Includes role-specific sections, an avatar, color-coded availability status, interest badges, and a profile completion indicator.\n\n3.  **Badge Component** (`src/components/ui/badge.tsx`):\n    *   A new, reusable UI component with multiple variants for displaying status indicators and tags.\n\nAll components are responsive and ready for integration into the profile pages in the next subtask.\n</info added on 2025-07-18T10:36:45.217Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 4,
            "title": "Create Profile Pages",
            "description": "Develop dedicated profile pages for viewing and editing user profiles",
            "details": "Create /profile page that shows current user's profile and allows editing. Implement conditional rendering based on user role (mentor/mentee). Include profile completion status and navigation. Ensure proper authentication checks and redirects.\n<info added on 2025-07-18T10:38:15.747Z>\nImplementation Update:\nThe profile page at `src/app/profile/page.tsx` is now fully integrated and functional.\n\nKey features completed:\n- Full integration with profile API endpoints (GET, POST, PUT) for creating and updating profiles.\n- A toggle between view (ProfileDisplay) and edit (ProfileForm) modes has been implemented.\n- The page handles both profile creation for new users and updates for existing ones.\n- Robust loading states, error handling, and form validation have been added.\n- Authentication checks are in place, redirecting unauthenticated users.\n- The UI is responsive and includes role-based conditional rendering for profile fields.\n</info added on 2025-07-18T10:38:15.747Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 5,
            "title": "Implement Profile Integration and Testing",
            "description": "Integrate profile functionality with existing authentication and test the complete flow",
            "details": "Connect profile management with the existing login system. Add profile completion checks to dashboard. Write comprehensive tests for API endpoints and UI components. Test profile creation, editing, and validation for both user types.\n<info added on 2025-07-18T10:42:15.297Z>\n**Implementation Summary:**\n\n*   **Dashboard & Profile Completion Flow:**\n    *   Integrated profile data fetching into the main dashboard, which now renders role-specific views for Mentees, Mentors, and Admins.\n    *   Created a `ProfileCompletionBanner` component that appears for users with incomplete profiles, providing a direct link to the profile editing page.\n    *   Key platform features are disabled until a user's profile is complete, enforcing the completion flow.\n    *   Implemented role-specific messaging in the banner to guide Mentees and Mentors appropriately.\n\n*   **Mentor Dashboard Enhancements:**\n    *   Developed a dedicated `MentorDashboard` to house mentor-specific functionalities.\n    *   Displayed the mentor's availability status prominently using color-coded badges.\n    *   The interface includes sections for managing mentees, scheduling sessions, and sharing resources.\n\n*   **Comprehensive Testing:**\n    *   Verified that all profile API endpoints for creation, editing, and retrieval are working correctly.\n    *   Confirmed that form validation and error handling are robust.\n    *   Tested all new components for responsive design and proper integration with the authentication system.\n</info added on 2025-07-18T10:42:15.297Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          }
        ]
      },
      {
        "id": 3,
        "title": "Opportunity Posting (Mentor Flow)",
        "description": "Enable authenticated Mentors to post new opportunities such as fellowships, jobs, or observerships.",
        "details": "Create a form for mentors to submit opportunities. The form should capture details like title, description, location, and experience level. Submitted posts should be saved with a 'pending approval' status.",
        "testStrategy": "Log in as a Mentor. Verify the 'Post Opportunity' feature is available. Submit a new post and confirm it is saved to the database with a pending status.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Opportunity Board & Application (Mentee Flow)",
        "description": "Implement the job board where Mentees can browse, filter, save, and apply for opportunities.",
        "details": "Create a page to display a list of approved opportunities. Implement simple filters for Location and Experience Level. Develop the application flow, including CV upload to AWS S3. Mentees should be able to save opportunities to a personal list.",
        "testStrategy": "Log in as a Mentee. Verify that approved posts are visible on the board. Test filters to ensure results are narrowed correctly. Test the application process, including successful CV upload.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the necessary database table(s) to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "Use a migration tool (e.g., Flyway, Alembic, Knex.js migrations). The 'users' table should include columns for 'id' (primary key), 'email' (unique), 'password_hash' (string), 'created_at', and 'updated_at'. Ensure the password field is designed to store a hashed value, not plaintext.",
            "status": "pending",
            "testStrategy": "Verify the migration runs successfully up and down. Manually inspect the database schema to confirm all columns, types, and constraints are correct. Write a unit test to insert and retrieve a dummy user record using the data access layer."
          },
          {
            "id": 2,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/auth/register) that allows new users to sign up.",
            "dependencies": [
              1
            ],
            "details": "The endpoint should accept user data (email, password) in the request body. It must validate the input (e.g., valid email format, password complexity). Before saving, hash the user's password using a strong algorithm like bcrypt. Return a success message or the newly created user object (without the password hash).",
            "status": "pending",
            "testStrategy": "Write integration tests. Test the happy path with valid data, ensuring a 201 Created status and correct user creation in the DB. Test failure cases: duplicate email, invalid email format, weak password, missing fields. Ensure the stored password is a hash."
          },
          {
            "id": 3,
            "title": "Implement JWT Generation and Validation Service",
            "description": "Create a reusable service or module for creating and verifying JSON Web Tokens (JWTs).",
            "dependencies": [],
            "details": "The service should have two main functions: `generateToken(user)` which takes a user object and returns a signed JWT containing user ID and role, and `verifyToken(token)` which validates a token's signature and expiration. Use a strong secret key stored securely in environment variables.",
            "status": "pending",
            "testStrategy": "Write unit tests for the service. Test token generation: ensure the payload contains the correct user data. Test token validation: check valid tokens, expired tokens, and tokens with invalid signatures. Mock any external dependencies like environment variable access."
          },
          {
            "id": 4,
            "title": "Develop User Login API Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/auth/login) for users to authenticate.",
            "dependencies": [
              1,
              3
            ],
            "details": "The endpoint accepts user credentials (email, password). It should find the user by email in the database, compare the provided password against the stored hash using the bcrypt compare function. If credentials are valid, use the JWT service to generate a token and return it to the client.",
            "status": "pending",
            "testStrategy": "Write integration tests. Test the happy path with correct credentials, ensuring a 200 OK status and a valid JWT in the response. Test failure cases: user not found, incorrect password. Ensure no sensitive information is leaked in error messages."
          },
          {
            "id": 5,
            "title": "Create Authentication Middleware for Protected Routes",
            "description": "Implement a middleware that intercepts requests to protected API endpoints, validates the JWT from the Authorization header, and attaches the user's identity to the request object.",
            "dependencies": [
              3
            ],
            "details": "The middleware should extract the token from the 'Authorization: Bearer <token>' header. Use the JWT service to verify the token. If valid, extract the user payload and attach it to the request context (e.g., `req.user`). If invalid or missing, return a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Write integration tests for a sample protected endpoint. Test with a valid token, ensuring the request proceeds and the endpoint receives user data. Test with no token, an expired token, and an invalid token, ensuring a 401 Unauthorized response is returned in all cases."
          }
        ]
      },
      {
        "id": 5,
        "title": "Admin Dashboard: User & Content Moderation",
        "description": "Build the core admin dashboard for manual approval of new users and all posted content.",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "Create an admin-only interface to view lists of pending user registrations and submitted opportunities. Implement 'approve' and 'reject' actions for both users and content. Admins must also be able to remove flagged/inappropriate posts and assign user roles.",
        "testStrategy": "Log in as an Admin. Verify access to the dashboard. Approve a pending user and a pending post, and confirm their status changes. Reject a user/post and confirm they are handled correctly.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Admin Role-Based Access Control (RBAC) Middleware",
            "description": "Create middleware to protect admin-only API routes, ensuring only users with the 'admin' role can access them.",
            "details": "The middleware should run after the standard authentication middleware. It will check the authenticated user's role from the session/token. If the role is not 'admin', it should return a 403 Forbidden error. This middleware will be applied to all new admin API endpoints.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 2,
            "title": "Create Admin API Endpoints for User Management",
            "description": "Develop API endpoints for admins to manage users, including approving/rejecting pending accounts and changing user roles.",
            "details": "Implement endpoints like `POST /api/admin/users/{id}/approve`, `POST /api/admin/users/{id}/reject`, and `PUT /api/admin/users/{id}/role`. Also include an endpoint `GET /api/admin/users?status=pending` to list users awaiting approval. These endpoints must be protected by the admin RBAC middleware.",
            "status": "pending",
            "dependencies": [
              1
            ],
            "parentTaskId": 5
          },
          {
            "id": 3,
            "title": "Create Admin API Endpoints for Content Moderation",
            "description": "Develop API endpoints for admins to moderate user-submitted content (opportunities), including approval, rejection, and deletion.",
            "details": "Implement endpoints like `POST /api/admin/opportunities/{id}/approve`, `POST /api/admin/opportunities/{id}/reject`, and `DELETE /api/admin/opportunities/{id}`. Include a `GET /api/admin/opportunities?status=pending` endpoint to fetch content awaiting moderation. Protect all endpoints with the admin RBAC middleware.",
            "status": "pending",
            "dependencies": [
              1
            ],
            "parentTaskId": 5
          },
          {
            "id": 4,
            "title": "Build User Management UI in Admin Dashboard",
            "description": "Implement the UI components within the existing admin dashboard to manage users by connecting to the new user management APIs.",
            "details": "Create a view that lists pending and active users, fetched from the new admin API. Add buttons for 'Approve', 'Reject', and a modal/form to change a user's role. Connect these UI elements to the corresponding API endpoints and handle state updates.",
            "status": "pending",
            "dependencies": [
              2
            ],
            "parentTaskId": 5
          },
          {
            "id": 5,
            "title": "Build Content Moderation UI in Admin Dashboard",
            "description": "Implement the UI components within the admin dashboard to moderate submitted opportunities by connecting to the new content moderation APIs.",
            "details": "Create a view to display a queue of pending opportunities fetched from the API. Each item should have 'Approve' and 'Reject' buttons. Implement functionality to view and delete any existing post. Connect all actions to the content moderation API endpoints and manage UI state accordingly.",
            "status": "pending",
            "dependencies": [
              3
            ],
            "parentTaskId": 5
          }
        ]
      },
      {
        "id": 6,
        "title": "Email Notification System",
        "description": "Integrate the Brevo email service to send automated notifications for key platform events.",
        "details": "Configure email triggers for: application submission (to mentor), admin approval of a post (to mentor), new user approval (to user), and custom announcements sent from the admin dashboard.",
        "testStrategy": "Trigger each event (e.g., apply for a job, approve a post) and verify that the correct email notification is sent to the intended recipient's inbox.",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Mentee Content Contribution",
        "description": "Allow Mentees to submit their own opportunities for admin approval and start case discussion threads.",
        "details": "Create a form for Mentees to submit external opportunities, which will enter the admin moderation queue. Implement a basic forum-like feature for creating and viewing case discussion threads.",
        "testStrategy": "As a Mentee, submit an opportunity and verify it appears in the admin moderation queue. Create a new discussion thread and verify it is visible to other users.",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Set Up User Database Schema",
            "description": "Create the necessary database table(s) to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "The 'users' table should include columns for id (primary key), username (unique), email (unique), hashed_password, created_at, and updated_at. Use a migration script to create and version the schema. Ensure password storage is secure using a strong hashing algorithm like bcrypt.",
            "status": "pending",
            "testStrategy": "Verify the table and columns are created correctly in the database. Write a unit test to ensure the migration script runs up and down successfully without errors."
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/auth/register) that allows new users to sign up.",
            "dependencies": [
              1
            ],
            "details": "The endpoint should accept username, email, and password. It must validate the input (e.g., password strength, valid email format), check for existing username/email, hash the password securely, and save the new user to the database. Return a success message or user object (without sensitive data) upon successful registration.",
            "status": "pending",
            "testStrategy": "Write integration tests to cover successful registration, registration with a duplicate email/username, and registration with invalid input (e.g., weak password, bad email format). Verify that the password stored in the database is properly hashed."
          },
          {
            "id": 3,
            "title": "Implement User Login API Endpoint",
            "description": "Create an API endpoint (e.g., POST /api/auth/login) for users to authenticate and receive an access token.",
            "dependencies": [
              1
            ],
            "details": "The endpoint should accept an email/username and password. It will find the user in the database and compare the provided password with the stored hash. If credentials are valid, generate a JSON Web Token (JWT) containing the user ID and an expiration date. Return the JWT to the client.",
            "status": "pending",
            "testStrategy": "Write integration tests for successful login with correct credentials, failed login with an incorrect password, and failed login for a non-existent user. Verify the structure and signature of the returned JWT."
          },
          {
            "id": 4,
            "title": "Develop Authentication Middleware for Protected Routes",
            "description": "Create a middleware function that can be applied to API routes that require an authenticated user.",
            "dependencies": [
              3
            ],
            "details": "The middleware should extract the JWT from the request's 'Authorization' header. It must verify the token's signature and expiration. If valid, it should decode the payload, identify the user, and attach the user object to the request for downstream handlers. If invalid, it should return a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Write unit tests for the middleware logic. Test cases should include a valid token, an expired token, an invalid/malformed token, and a missing token. Ensure it correctly passes control or returns a 401 status."
          },
          {
            "id": 5,
            "title": "Implement 'Get User Profile' Protected Endpoint",
            "description": "Create a protected API endpoint (e.g., GET /api/users/me) that returns the profile information of the currently authenticated user.",
            "dependencies": [
              4
            ],
            "details": "This endpoint will be protected by the authentication middleware. It should use the user information attached to the request by the middleware to fetch the user's details (excluding sensitive data like the password hash) from the database and return them as a JSON object.",
            "status": "pending",
            "testStrategy": "Write an integration test that first logs in a user to get a token, then uses that token to successfully call this endpoint and verify the returned user data. Also, test that calling the endpoint without a valid token results in a 401 Unauthorized error."
          }
        ]
      },
      {
        "id": 8,
        "title": "Search Functionality for Users",
        "description": "Implement search functionality for mentors to find mentees.",
        "details": "Develop a search interface for Mentors to find Mentees based on profile criteria like interests and location. This complements the existing opportunity search for Mentees.",
        "testStrategy": "Log in as a Mentor. Use the search feature to filter mentees by location and interests. Verify that the search results are accurate based on existing mentee profiles.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Admin Analytics & Audit Logs",
        "description": "Enhance the admin dashboard with simple analytics and audit logging.",
        "details": "Add a section to the admin dashboard to display simple metrics like total user sign-ups and total number of posts. Implement a logging system to record key admin and user actions (e.g., user approved, post deleted, role changed).",
        "testStrategy": "As an Admin, view the analytics dashboard and confirm the counts are correct. Perform an action like approving a user, then check the audit log to ensure the action was recorded with the correct details.",
        "priority": "low",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "MVP Launch Readiness & Finalization",
        "description": "Implement final UI/UX polish, legal requirements, and initial content for launch.",
        "details": "Ensure the entire application is mobile responsive. Implement the legal disclaimer and terms of service modal to be shown on first login. Create an admin function or script for initial content seeding (jobs/fellowships). Perform a final review of security practices, including encrypted storage for sensitive data.",
        "testStrategy": "Test the application on various screen sizes (desktop, tablet, mobile). Verify the legal disclaimer appears on first login and requires acceptance. Confirm initial content is seeded correctly and visible on the platform.",
        "priority": "high",
        "dependencies": [
          4,
          5,
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the necessary database table(s) to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "Define a 'users' table with columns for id (primary key), email (unique), hashed_password, created_at, and updated_at. Use a database migration tool (e.g., Flyway, Alembic, Knex.js) to create and apply the schema changes.",
            "status": "pending",
            "testStrategy": "Verify the migration runs successfully. Manually inspect the database schema to confirm the 'users' table and its columns are created correctly with the specified constraints."
          },
          {
            "id": 2,
            "title": "Implement Secure Password Hashing Service",
            "description": "Create a reusable service or module for hashing and verifying user passwords securely.",
            "dependencies": [],
            "details": "Use a strong, adaptive hashing algorithm like bcrypt or Argon2. Create two functions: one `hashPassword(plainTextPassword)` that returns a hash, and another `verifyPassword(plainTextPassword, hash)` that returns a boolean. Do not use outdated algorithms like MD5 or SHA1.",
            "status": "pending",
            "testStrategy": "Write unit tests for the hashing service. Test that a given password produces a valid hash. Test that the `verifyPassword` function correctly returns true for the correct password and false for an incorrect one. Ensure the hash output changes for the same input due to salting."
          },
          {
            "id": 3,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/auth/register) for new users to create an account.",
            "dependencies": [
              1,
              2
            ],
            "details": "The endpoint should accept user data (e.g., email, password) in the request body. Validate the input (e.g., check for valid email format, password complexity). Use the Password Hashing Service to hash the password before storing the new user record in the database. Return a success message or a newly created user object (without the password hash).",
            "status": "pending",
            "testStrategy": "Write integration tests. Test the happy path with valid data, ensuring a 201 Created status and a new user in the DB. Test failure cases: duplicate email, invalid email format, weak password, missing fields. Ensure the stored password is a hash, not plaintext."
          },
          {
            "id": 4,
            "title": "Develop User Login API Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/auth/login) for existing users to authenticate.",
            "dependencies": [
              1,
              2
            ],
            "details": "The endpoint should accept user credentials (email, password). Find the user by email in the database. Use the Password Hashing Service to compare the provided password with the stored hash. If they match, generate a JSON Web Token (JWT) containing the user's ID and role. Return the JWT to the client.",
            "status": "pending",
            "testStrategy": "Write integration tests. Test successful login with correct credentials, ensuring a 200 OK status and a valid JWT is returned. Test failed login attempts with incorrect password or non-existent email, ensuring an appropriate error status (e.g., 401 Unauthorized)."
          },
          {
            "id": 5,
            "title": "Create Authentication Middleware for Protected Routes",
            "description": "Implement middleware to verify the JWT on incoming requests to secure specific API endpoints.",
            "dependencies": [
              4
            ],
            "details": "The middleware should extract the JWT from the 'Authorization' header (e.g., 'Bearer <token>'). It must then verify the token's signature and expiration. If valid, decode the payload to identify the user and attach the user information to the request object for use in subsequent handlers. If invalid, it should return a 401 Unauthorized or 403 Forbidden error.",
            "status": "pending",
            "testStrategy": "Write integration tests for a sample protected endpoint. Test that a request with a valid token is allowed to proceed. Test that requests with no token, an invalid token, or an expired token are rejected with the correct HTTP status code."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-18T05:40:25.172Z",
      "updated": "2025-07-19T03:51:46.145Z",
      "description": "Tasks for master context"
    }
  }
}